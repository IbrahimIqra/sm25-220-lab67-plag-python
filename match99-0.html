<html>
<head>
<title>A67_Sec23_22101445_Abrar-Iqbal-Turja.txt</title>
</head>
<body bgcolor="white">
<hr/>
A67_Sec23_22101445_Abrar-Iqbal-Turja.txt<p></p><pre>
Assignment 06
---------------------


# Task 4

class Node:
def __init__(self, value):
self.value = value
self.left = None
self.right = None

def swap_child(root, level, M):
if root is None:
return

# If we're at or above the target level, swap children
if level &gt;= M:
root.left, root.right = root.right, root.left

# Recursively process left and right subtrees
swap_child(root.left, level + 1, M)
swap_child(root.right, level + 1, M)

# Helper function to create the tree from the example
def create_tree():
<a name="0"></a><font color="#FF0000"><a href="match99-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

root = Node('A')
root.left = Node('B')
root.right = Node('C')
root.left.left = Node('D')
root.left.right = Node('E')
root.right.right = Node('F')
root.left.left.left = Node('G')
root.left.left.right = Node('H')
root.left.right.right = Node('I')
root.right.right.left = Node('J')
</font>return root

# Helper function to print the tree (in-order traversal)
def print_tree(root):
if root:
print_tree(root.left)
print(root.value, end=' ')
print_tree(root.right)

# Create the tree
root = create_tree()

# Print original tree
print("Original tree:")
print_tree(root)
print()

# Call the swap_child function
swap_child(root, 0, 2)

# Print the modified tree
print("Modified tree:")
print_tree(root)






# Task 5


class Node:
def __init__(self, elem):
self.elem = elem
self.left = None
self.right = None

def subtract_summation(root):
if root is None:
return 0

left_sum = subtract_summation(root.left)
right_sum = subtract_summation(root.right)

return root.elem + left_sum - right_sum

# Helper function to create the tree from the example
def create_sample_tree():
<a name="1"></a><font color="#00FF00"><a href="match99-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

root = Node(71)
root.left = Node(62)
root.right = Node(89)
root.left.left = Node(80)
root.left.right = Node(75)
root.right.left = Node(41)
root.right.right = Node(3)
root.left.left.left = Node(57)
root.left.left.right = Node(58)
root.right.left.right = Node(19)
</font>return root

# Create the sample tree
sample_root = create_sample_tree()

# Call the subtract_summation function and print the result
result = subtract_summation(sample_root)
print(result)



# Task 6

class TreeNode:
def __init__(self, val=0, left=None, right=None):
self.val = val
self.left = left
self.right = right

def difference_odd_even_levels(root):
if not root:
return 0

def dfs(node, level, odd_sum, even_sum):
if not node:
return odd_sum, even_sum

if level % 2 == 0:
even_sum += node.val
else:
odd_sum += node.val

left_odd, left_even = dfs(node.left, level + 1, odd_sum, even_sum)
right_odd, right_even = dfs(node.right, level + 1, odd_sum, even_sum)

return max(left_odd, right_odd), max(left_even, right_even)

odd_sum, even_sum = dfs(root, 1, 0, 0)
return odd_sum - even_sum

# Create the binary tree from the sample input
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.right.left = TreeNode(5)
root.right.right = TreeNode(6)
root.right.left.left = TreeNode(7)
root.right.left.right = TreeNode(8)

# Calculate and print the result
result = difference_odd_even_levels(root)
print(result)






Assignment 07
---------------------



# Task 4


class TreeNode:
def __init__(self, val=0, left=None, right=None):
self.val = val
self.left = left
self.right = right

def rangeSum(root, low, high):
def dfs(node):
if not node:
return 0

if low &lt;= node.val &lt;= high:
return node.val + dfs(node.left) + dfs(node.right)
elif node.val &lt; low:
return dfs(node.right)
else:
return dfs(node.left)

return dfs(root)

# Create the first binary search tree
root1 = TreeNode(8)
root1.left = TreeNode(4)
root1.right = TreeNode(12)
root1.left.left = TreeNode(2)
root1.left.right = TreeNode(6)
root1.right.left = TreeNode(10)
root1.right.right = TreeNode(14)

# Create the second binary search tree
root2 = TreeNode(10)
root2.left = TreeNode(5)
root2.right = TreeNode(15)
root2.left.left = TreeNode(3)
root2.left.right = TreeNode(7)
root2.right.right = TreeNode(18)

# Test cases
print(rangeSum(root1, 5, 13)) # Should print 36
print(rangeSum(root2, 7, 15)) # Should print 32





# Task 5


class TreeNode:
def __init__(self, val=0, left=None, right=None):
self.val = val
self.left = left
self.right = right

def mirrorSum(root):
def dfs(left, right):
if not left and not right:
return 0
<a name="2"></a><font color="#0000FF"><a href="match99-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

if not left or not right:
return 0

return left.val + right.val + dfs(left.left, right.right) + dfs(left.right, right.left)
</font>
if not root:
return 0

return dfs(root.left, root.right)

# Create the first example tree
root1 = TreeNode(10)
root1.left = TreeNode(6)
root1.right = TreeNode(15)
root1.left.left = TreeNode(3)
root1.left.right = TreeNode(8)
root1.right.left = TreeNode(12)
root1.right.right = TreeNode(20)

# Create the second example tree
root2 = TreeNode(20)
root2.left = TreeNode(15)
root2.right = TreeNode(25)
root2.left.left = TreeNode(10)
root2.left.right = TreeNode(18)
root2.right.right = TreeNode(30)

# Test cases
print(mirrorSum(root1)) # Should print 64
print(mirrorSum(root2)) # Should print 80



# Task 6


class TreeNode:
def __init__(self, val=0, left=None, right=None):
self.val = val
self.left = left
self.right = right

def isBST(root):
def validate(node, min_val, max_val):
if not node:
return True

<a name="3"></a><font color="#00FFFF"><a href="match99-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

if node.val &lt;= min_val or node.val &gt;= max_val:
return False

return validate(node.left, min_val, node.val) and validate(node.right, node.val, max_val)

return validate(root, float('-inf'), float('inf'))
</font>
# Create the first example tree (not a BST)
root1 = TreeNode(4)
root1.left = TreeNode(9)
root1.right = TreeNode(2)
root1.left.left = TreeNode(3)
root1.left.right = TreeNode(-5)
root1.right.right = TreeNode(7)

# Create the second example tree (a BST)
root2 = TreeNode(4)
root2.left = TreeNode(2)
root2.right = TreeNode(7)
root2.left.left = TreeNode(-5)
root2.left.right = TreeNode(3)
root2.right.right = TreeNode(9)

# Test cases
print(isBST(root1)) # Should print False
print(isBST(root2)) # Should print True
</pre>
</body>
</html>
