<html>
<head>
<title>[WRONG-TYPE]A67_Sec13_22101067_Meahjabin-Mourin.txt</title>
</head>
<body bgcolor="white">
<hr/>
[WRONG-TYPE]A67_Sec13_22101067_Meahjabin-Mourin.txt<p></p><pre>
class BTNode:
  def __init__(self, elem):
    self.elem = elem
    self.right = None
    self.left = None



def inorder(root):
  if root == None:
    return

  inorder(root.left)
  print(root.elem, end = ' ')
  inorder(root.right)



def tree_construction(arr, i = 1):
  if i&gt;=len(arr) or arr[i] == None:
    return None
  p = BTNode(arr[i])
  p.left = tree_construction(arr, 2*i)
  p.right = tree_construction(arr, 2*i+1)
  return p


root2 = tree_construction([None, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', None, None, None, 'I', 'J', None, 'k'])
inorder(root2)



def LCA(root, x, y):
  #To Do
  pass #delete this line once you're done


#DRIVER CODE
root = BTNode(15)
root.left = BTNode(10)
root.left.left = BTNode(8)
#Write by yourself from the given tree (Create parent node and its corresponding left and right children nodes)
#check all the sample inputs given
#You can take help by seeing the driver code of Lab-6



def find_path(root, key):
  #To Do
  pass #delete this line once you're done


#DRIVER CODE
#Write by yourself from the given tree
root = BTNode(30)
#..
#..
#..
print("Expected Output: [30,10,15]")
print(find_path(root,15))

print("Expected Output: No Path Found")
print(find_path(root,50))



def sum_of_leaves(root, sum):
  #To Do
  pass #delete this line once you're done


#DRIVER CODE
#Write by yourself from the given tree
root = BTNode(30)
#..
#..
#..

print("Expected Output: 108")
print(sum_of_leaves(root, 0))



def rangeSum(root, low, high):
   if root is None:
        return 0

    # If current node is smaller than low, go right
   if root.elem &lt; low:
        return rangeSum(root.right, low, high)

    # If current node is larger than high, go left
<a name="2"></a><font color="#0000FF"><a href="match85-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

   if root.elem &gt; high:
        return rangeSum(root.left, low, high)

    # Node is within range
   return (root.elem +
            rangeSum(root.left, low, high) +
            rangeSum(root.right, low, high))
</font>

#DRIVER CODE
print("---------------------Test#1---------------------")
#Example Tree 1
root = BTNode(8)
n1 = BTNode(4)
n2 = BTNode(12)
n3 = BTNode(2)
n4 = BTNode(6)
n5 = BTNode(10)
n6 = BTNode(14)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4

n2.left = n5
n2.right = n6
print("Expected Output: 36")
print("You output     :",rangeSum(root, 5, 13))

print("---------------------Test#2---------------------")

#Example Tree 1
root = BTNode(10)
n1 = BTNode(5)
n2 = BTNode(15)
n3 = BTNode(3)
n4 = BTNode(7)

n6 = BTNode(18)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4

n2.right = n6
print("Expected Output: 32")
print("You output     :",rangeSum(root, 7, 15))



def mirror_sum(root):
  if root is None:
        return 0

def helper(left, right):
        if left is None and right is None:
            return 0
        if left is None or right is None:
            return 0
        return left.elem + right.elem + helper(left.left, right.right) + helper(left.right, right.left)
        return root.elem + helper(root.left, root.right)


#DRIVER CODE
print("---------------------Test#1---------------------")
#Example Tree 1
root = BTNode(10)
n1 = BTNode(6)
n2 = BTNode(15)
n3 = BTNode(3)
n4 = BTNode(8)
n5 = BTNode(12)
n6 = BTNode(20)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4

n2.left = n5
n2.right = n6
print("Expected Output: 64")
print("You output     :",mirror_sum(root))

print("---------------------Test#2---------------------")

#Example Tree 1
root = BTNode(20)
n1 = BTNode(15)
n2 = BTNode(25)
n3 = BTNode(10)
n4 = BTNode(18)
n5 = BTNode(5)
n6 = BTNode(30)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4

n3.left = n5
n2.right = n6
print("Expected Output: 80")
print("You output     :",mirror_sum(root))



def isBST(root, min_val=float('-inf'), max_val=float('inf')):
    if root is None:
        return True

    # If value violates the BST rule
<a name="3"></a><font color="#00FFFF"><a href="match85-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

    if root.elem &lt;= min_val or root.elem &gt;= max_val:
        return False

    # Left must be &lt; root.elem, Right must be &gt; root.elem
    return (isBST(root.left, min_val, root.elem) and
            isBST(root.right, root.elem, max_val))
</font>

#DRIVER CODE
print("---------------------Test#1---------------------")
#Example Tree 1
root = BTNode(4)
n1 = BTNode(9)
n2 = BTNode(2)
n3 = BTNode(3)
n4 = BTNode(-5)
n6 = BTNode(7)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4

n2.right = n6
print("Expected Output: False")
print("You output     :",isBST(root))

print("---------------------Test#2---------------------")

#Example Tree 1
root = BTNode(4)
n1 = BTNode(2)
n2 = BTNode(7)
n3 = BTNode(-5)
n4 = BTNode(3)
n6 = BTNode(9)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4

n2.right = n6
print("Expected Output: True")
print("You output     :",isBST(root))



#####lab6 task4




class BTNode:
    def __init__(self, elem):
        self.elem = elem
        self.right = None
        self.left = None

# Inorder traversal
def inorder(root):
    if root:
        inorder(root.left)
        print(root.elem, end=" ")
        inorder(root.right)

# Swap children from level M and above
def swap_child(root, level, M):
    if root is None:
        return
    # If current level &gt;= M → swap
    if level &gt;= M:
        root.left, root.right = root.right, root.left
    swap_child(root.left, level+1, M)
    swap_child(root.right, level+1, M)


# Build tree from assignment
<a name="0"></a><font color="#FF0000"><a href="match85-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

root = BTNode('A')
root.left = BTNode('B')
root.right = BTNode('C')
root.left.left = BTNode('D')
root.left.right = BTNode('E')
root.right.right = BTNode('F')
root.left.left.left = BTNode('G')
root.left.left.right = BTNode('H')
root.left.right.left = BTNode('I')
root.left.right.right = BTNode('J')

print('Given Tree Inorder Traversal: ', end = '')
inorder(root)   # Before swapping
</font>print()

swap_child(root, 0, 2)   # Start from level 0, swap from level 2 and above

print('Swapped Tree Inorder Traversal: ', end = '')
inorder(root)   # After swapping
print()



####task5




class BTNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None


def subtract_summation(root):
    # helper function to calculate sum of subtree
    def helper(node):
        if node is None:
            return 0
        return node.data + helper(node.left) + helper(node.right)

    if root is None:
        return 0
<a name="1"></a><font color="#00FF00"><a href="match85-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_5.gif"/></a>

    return helper(root.left) - helper(root.right)




root = BTNode(71)
root.left = BTNode(27)
root.right = BTNode(62)

root.left.left = BTNode(80)
root.left.right = BTNode(75)

root.left.left.left = BTNode(87)
root.left.left.right = BTNode(56)

root.right.left = BTNode(41)
root.right.left.right = BTNode(3)
</font>
root.right.left.right.left = BTNode(19)
root.right.left.right.right = BTNode(89)

# ----------------- Test -----------------
print(subtract_summation(root))   # ✅ should print 111




####task6





class BTNode:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def level_sum(root):
    def solve(node, level):
        if node is None:
            return 0
        if level % 2 == 0:   # even level → subtract
            return -node.val + solve(node.left, level + 1) + solve(node.right, level + 1)
        else:                # odd level → add
            return node.val + solve(node.left, level + 1) + solve(node.right, level + 1)
    return solve(root, 0)


# DRIVER CODE
root = BTNode(1)
n2 = BTNode(2)
n3 = BTNode(3)
n4 = BTNode(4)
n5 = BTNode(5)
n6 = BTNode(6)
n7 = BTNode(7)
n8 = BTNode(8)

root.left = n2
root.right = n3
n2.left = n4
n3.left = n5
n3.right = n6
n5.left = n7
n5.right = n8

print(level_sum(root))   # ✅ This will print 4



</pre>
</body>
</html>
